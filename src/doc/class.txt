1. 类的实现与继承 (class, extends)

- 实现
  - 通过关键字 class 来声明类
  - 类的属性必须声明数据类型,并在构造函数内部进行初始化


- 继承
  - 声明 子类 extends 基类
  - 在子类构造函数必须使用 super(),再声明子类实例属性;

2. 类成员修饰符
公有成员 public (默认) ---- 当前类,子类,实例都可以访问.
受保护的成员 protected ---- 只能在当前类和子类访问,不能实例访问.
私有成员 private ---- 只能被当前类调用,不被子类或实例访问.
只读成员 readonly ---- 只读属性必须初始化;只读属性是实例属性,不具备继承性质;但可被子类,实例等访问到.
静态成员 static ---- 只能通过类名来调用,可以被继承.

除了类的成员可以添加修饰符,类的构造函数的参数可以添加修饰符;
当类的构造函数的参数添加修饰符,可将这些参数自动转为类的实例属性,这样可减少类内部的定义了.

为简便书写,建议在类的参数前定义类的成员修饰符(public, protected, private, readonly, static)


- 注意
  - 当构造函数添加为私有修饰符时,当前类不能被初始化,或被继承.
  - 当构造函数添加为受保护的修饰符时,当前类不能被实例化,只能被继承.


3. 抽象类与多态
抽象类 abstract : 作为一个只能被继承而不能被实例化的类.可以理解为多个子类所共有的性质的类.
比如动物都会有吃喝拉撒的行为,而这些行为就是动物的共性.

抽象类利于代码的复用,类的抽象方法可实现类方法的多态.

abstract class Animal {
  具体实现
  run () { console.log('the animal running) }

  抽象类方法(不具体实现)
  abstract eat (): void
}


抽象方法: 不指定方法的具体实现,但在子类必须定义.
abstract eat (): void

多态: 是在在不同的实例上,某一方法有不同的具体实现.
比如猫吃鱼,狗啃骨,鸡吃虫,兔吃萝卜...


4. this 类型 与 链式调用
this 类型: 是指类的方法返回一个 this,这样就有利于链式调用.

